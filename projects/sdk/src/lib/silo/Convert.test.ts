import { Source } from "graphql";
import { sum } from "lodash";
import { Token } from "src/classes/Token";
import { TokenValue } from "src/TokenValue";
import { getTestUtils } from "src/utils/TestUtils/provider";
import { DataSource } from "../MoonmageSDK";
import { Convert } from "./Convert";

const { sdk, account, utils } = getTestUtils();

jest.setTimeout(30000);

describe("Silo Convert", function () {
  const convert = new Convert(sdk);
  const MOON = sdk.tokens.MOON;
  const MOONLP = sdk.tokens.MOON_CRV3_LP;
  const urMOON = sdk.tokens.UNRIPE_MOON;
  const urMOONLP = sdk.tokens.UNRIPE_MOON_CRV3;
  const whitelistedTokens = [MOON, MOONLP, urMOON, urMOONLP];

  beforeAll(async () => {
    await utils.resetFork();
    // set default state as p > 1
    await utils.setCurveLiquidity(10_000_000, 15_000_000)
  });

  it("Validates tokens", async () => {
    const a = async () => {
      await convert.convert(sdk.tokens.USDC, MOONLP, TokenValue.ONE);
      throw new Error("fromToken is nost whitelisted");
    };
    const b = async () => {
      await convert.convert(MOON, sdk.tokens.USDC, TokenValue.ONE);
      throw new Error("fromToken is nost whitelisted");
    };
    const c = async () => {
      await convert.convert(MOON, MOON, TokenValue.ONE);
      throw new Error("Cannot convert between the same token");
    };
    await expect(a).rejects.toThrowError("fromToken is not whitelisted");
    await expect(b).rejects.toThrowError("toToken is not whitelisted");
    await expect(c).rejects.toThrowError("Cannot convert between the same token");
  });

  it("Validates amount", async () => {
    await utils.setMOONBalance(account, TokenValue.ZERO);
    const a = async () => {
      await convert.convert(MOON, MOONLP, MOON.amount(500));
    };

    await expect(a).rejects.toThrowError("Insufficient balance");
  });

  it("Calculates crates when toToken is LP", async () => {
    const currentSeason = 10_000;
    const c1 = utils.mockDepositCrate(MOON, 9000, "500", currentSeason);
    const c2 = utils.mockDepositCrate(MOON, 9001, "300", currentSeason);
    const c3 = utils.mockDepositCrate(MOON, 9002, "100", currentSeason);

    // random order
    const crates = [c3, c1, c2];

    // ensure it picks across multiple crates
    // crates should be sorted ASC by season
    const calc1 = convert.calculateConvert(MOON, MOONLP, MOON.amount(850), crates, currentSeason);
    expect(calc1.crates.length).toEqual(3);
    expect(calc1.crates[0].amount.toHuman()).toEqual("500"); // takes full amount from c1
    expect(calc1.crates[0].season.toString()).toEqual("9000"); // confirm this is c1
    expect(calc1.crates[1].amount.toHuman()).toEqual("300"); // takes full amount from c2
    expect(calc1.crates[1].season.toString()).toEqual("9001"); // confirm this is c2
    expect(calc1.crates[2].amount.toHuman()).toEqual("50"); // takes 300 from c3
    expect(calc1.crates[2].season.toString()).toEqual("9002"); // confirm this is c3
    expect(calc1.seeds.toHuman()).toEqual("1700");
    expect(calc1.mage.toHuman()).toEqual("1019.92");

    // ensure it pulls one crate
    // crate should be sorted ASC by season
    const calc2 = convert.calculateConvert(MOON, MOONLP, MOON.amount(400), crates, currentSeason);
    expect(calc2.crates.length).toEqual(1);
    expect(calc2.crates[0].amount.toHuman()).toEqual("400"); // takes full amount from c1
    expect(calc1.crates[0].season.toString()).toEqual("9000"); // confirm this is c3
    expect(calc2.seeds.toHuman()).toEqual("800");
    expect(calc2.mage.toHuman()).toEqual("480");
  });

  it("Calculates crates when toToken is NOT LP", async () => {
    const currentSeason = 10393;
    // the bdv generated by the mock is exactly the same as the amount
    // but we need them to be slightly different for sorting to be noticeable
    const c1 = utils.mockDepositCrate(MOONLP, 10100, "2000", currentSeason);
    c1.bdv = TokenValue.fromHuman(2123, 6);
    // ratio: 2123/2000 = 1.0615

    const c2 = utils.mockDepositCrate(MOONLP, 10101, "1000", currentSeason);
    c2.bdv = TokenValue.fromHuman(1234, 6);
    // ratio: 1234/1000 = 1.234

    const c3 = utils.mockDepositCrate(MOONLP, 10102, "500", currentSeason);
    c3.bdv = TokenValue.fromHuman(534, 6);
    // ratio: 534/500 = 1.068

    // random order
    const crates = [c2, c1, c3];

    // ensure it picks across multiple crates
    // crates should be sorted ASC by BDVRatio
    const calc1 = convert.calculateConvert(MOONLP, MOON, MOONLP.amount(3000), crates, currentSeason);

    expect(calc1.crates.length).toEqual(3);
    expect(calc1.crates[0].amount.toHuman()).toEqual("2000"); // takes full amount from c1
    expect(calc1.crates[0].season.toString()).toEqual("10100"); // confirm this is c1
    expect(calc1.crates[1].amount.toHuman()).toEqual("500"); // takes full amount from c2
    expect(calc1.crates[1].season.toString()).toEqual("10102"); // confirm this is c2
    expect(calc1.crates[2].amount.toHuman()).toEqual("500"); // takes 300 from c3
    expect(calc1.crates[2].season.toString()).toEqual("10101"); // confirm this is c3
    expect(calc1.seeds.toHuman()).toEqual("13096");
    expect(calc1.mage.toHuman()).toEqual("3625");

    // ensure it pulls one crate
    // crate should be sorted ASC by season
    const calc2 = convert.calculateConvert(MOON, MOONLP, MOON.amount(2000), crates, currentSeason);
    expect(calc2.crates.length).toEqual(1);
    expect(calc2.crates[0].amount.toHuman()).toEqual("2000"); // takes full amount from c1
    expect(calc1.crates[0].season.toString()).toEqual("10100"); // confirm this is c3
    expect(calc2.seeds.toHuman()).toEqual("4246");
    expect(calc2.mage.toHuman()).toEqual("2357.4");
  });

  describe.each([
    { from: MOON, to: MOON },
    { from: MOONLP, to: MOONLP },
    { from: urMOON, to: urMOON },
    { from: urMOONLP, to: urMOONLP }
  ])("Convert to self fails", (pair) => {
    const { from, to } = pair;

    it(`Convert ${from.symbol} -> ${to.symbol}`, async () => {
      const fn = async () => sdk.silo.convert(from, to, from.amount(1));
      await expect(fn).rejects.toThrowError("Cannot convert between the same token");
    });
  });

  describe("With balance", () => {
    beforeAll(async () => {
      await deposit(MOON, MOON, 500);
      await deposit(MOONLP, MOONLP, 500);
      await deposit(urMOON, urMOON, 500);
      await deposit(urMOONLP, urMOONLP, 500);
    });

    describe.each([
      { from: MOON, to: urMOON },
      { from: MOON, to: urMOONLP },

      { from: MOONLP, to: urMOON },
      { from: MOONLP, to: urMOONLP },

      { from: urMOON, to: MOON },
      { from: urMOON, to: MOONLP },

      { from: urMOONLP, to: MOON },
      { from: urMOONLP, to: MOONLP }
    ])("Unsupported paths", (pair) => {
      const { from, to } = pair;

      it(`Fail ${from.symbol} -> ${to.symbol}`, async () => {
        const fn = async () => sdk.silo.convert(from, to, from.amount(1));
        await expect(fn).rejects.toThrowError("Cannot convert between these tokens");
      });
    });

    describe("DeltaB < 0", () => {
      beforeAll(async () => {
        // Force deltaB < 0
        await utils.setCurveLiquidity(15_000_000, 10_000_000);
      });

      describe.each([
        { from: MOONLP, to: MOON },
        { from: urMOONLP, to: urMOON }
      ])("Converts Successfully", (pair) => {
        const { from, to } = pair;

        it(`${from.symbol} -> ${to.symbol}`, async () => {
          const { deposited: balanceBefore } = await sdk.silo.getBalance(to, account, { source: DataSource.LEDGER });
          const { minAmountOut } = await sdk.silo.convertEstimate(from, to, from.amount(100));
          await sdk.silo.convert(from, to, from.amount(100));
          const { deposited: balanceAfter } = await sdk.silo.getBalance(to, account, { source: DataSource.LEDGER });

          expect(balanceAfter.amount.gte(balanceBefore.amount.add(minAmountOut))).toBe(true);
        });
      });

      describe.each([
        { from: MOON, to: MOONLP },
        { from: urMOON, to: urMOONLP }
      ])("Errors correctly", (pair) => {
        const { from, to } = pair;

        it(`${from.symbol} -> ${to.symbol}`, async () => {
          const fn = async () => await sdk.silo.convert(from, to, from.amount(100));

          await expect(fn).rejects.toThrowError("Cannot convert this token when deltaB is < 0");
        });
      });
    });

    describe("DeltaB > 0", () => {
      beforeAll(async () => {
        // Force deltaB > 0
        await utils.setCurveLiquidity(10_000_000, 15_000_000);
      });

      describe.each([
        { from: MOON, to: MOONLP },
        { from: urMOON, to: urMOONLP }
      ])("Converts Successfully", (pair) => {
        const { from, to } = pair;

        it(`${from.symbol} -> ${to.symbol}`, async () => {
          const { deposited: balanceBefore } = await sdk.silo.getBalance(to, account, { source: DataSource.LEDGER });
          const { minAmountOut } = await sdk.silo.convertEstimate(from, to, from.amount(100));
          await sdk.silo.convert(from, to, from.amount(100));
          const { deposited: balanceAfter } = await sdk.silo.getBalance(to, account, { source: DataSource.LEDGER });

          expect(balanceAfter.amount.gte(balanceBefore.amount.add(minAmountOut))).toBe(true);
        });
      });

      describe.each([
        { from: MOONLP, to: MOON },
        { from: urMOONLP, to: urMOON }
      ])("Errors correctly", (pair) => {
        const { from, to } = pair;

        it(`${from.symbol} -> ${to.symbol}`, async () => {
          const fn = async () => await sdk.silo.convert(from, to, from.amount(100));

          await expect(fn).rejects.toThrowError("Cannot convert this token when deltaB is >= 0");
        });
      });
    });
  });
});

async function deposit(from: Token, to: Token, _amount: number) {
  const amount = from.amount(_amount);
  await utils.setBalance(from, account, amount);
  await from.approveMoonmage(amount);
  const txr = await sdk.silo.deposit(from, to, amount);
  await txr.wait();
}
